'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.abiPolyfill = exports.denominations = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.setupBonds = setupBonds;
exports.capitalizeFirstLetter = capitalizeFirstLetter;
exports.singleton = singleton;
exports.denominationMultiplier = denominationMultiplier;
exports.interpretQuantity = interpretQuantity;
exports.splitValue = splitValue;
exports.formatBalance = formatBalance;
exports.formatBlockNumber = formatBlockNumber;
exports.isNullData = isNullData;

var _oo = require('oo7');

var _bignumber = require('bignumber.js');

var _bignumber2 = _interopRequireDefault(_bignumber);

var _abis = require('./abis.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function setupBonds() {
	var _api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parity.api;

	console.log("setupBonds...");
	_api.parity.netChain().then(function (c) {
		return console.log('setupBonds: on chain ' + c);
	});

	var api = _api;
	var bonds = {};

	api.util.abiSig = function (name, inputs) {
		return api.util.sha3(name + '(' + inputs.join() + ')');
	};

	api.util.cleanup = function (value, type) {
		// TODO: make work with arbitrary depth arrays
		if (value instanceof Array && type.match(/bytes[0-9]+/)) {
			// figure out if it's an ASCII string hiding in there:
			var ascii = '';
			for (var i = 0, ended = false; i < value.length && ascii !== null; ++i) {
				if (value[i] === 0) {
					ended = true;
				} else {
					ascii += String.fromCharCode(value[i]);
				}
				if (ended && value[i] !== 0 || !ended && (value[i] < 32 || value[i] >= 128)) {
					ascii = null;
				}
			}
			value = ascii === null ? api.util.bytesToHex(value) : ascii;
		}
		if (type.substr(0, 4) == 'uint' && +type.substr(4) <= 48) {
			value = +value;
		}
		return value;
	};

	// returns [functionName, argsByName]
	api.util.abiUnencode = function (abi, data) {
		var s = data.substr(2, 8);
		var op = abi.find(function (f) {
			return f.type == 'function' && api.util.abiSig(f.name, f.inputs.map(function (i) {
				return i.type;
			})).substr(2, 8) === s;
		});
		if (!op) {
			console.warn('Unknown function ID: ' + s);
			return null;
		}
		var argsByIndex = api.util.abiDecode(op.inputs.map(function (f) {
			return f.type;
		}), '0x' + data.substr(10)).map(function (v, i) {
			return api.util.cleanup(v, op.inputs[i].type);
		});
		var argsByName = {};
		op.inputs.forEach(function (f, i) {
			argsByName[f.name] = argsByIndex[i];
		});
		return [op.name, argsByName, argsByIndex];
	};

	var TransformBond = function (_oo7TransformBond) {
		_inherits(TransformBond, _oo7TransformBond);

		function TransformBond(f) {
			var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
			var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
			var latched = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
			var mayBeNull = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

			_classCallCheck(this, TransformBond);

			return _possibleConstructorReturn(this, (TransformBond.__proto__ || Object.getPrototypeOf(TransformBond)).call(this, f, a, d, latched, mayBeNull, api));
		}

		_createClass(TransformBond, [{
			key: 'map',
			value: function map(f) {
				return new TransformBond(f, [this]);
			}
		}, {
			key: 'sub',
			value: function sub(name) {
				return new TransformBond(function (r, n) {
					return r[n];
				}, [this, name]);
			}
		}], [{
			key: 'all',
			value: function all(list) {
				return new TransformBond(function () {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					return args;
				}, list);
			}
		}]);

		return TransformBond;
	}(_oo.TransformBond);

	// TODO: Use more generic means to check on number, ideally push notification.


	var SubscriptionBond = function (_Bond) {
		_inherits(SubscriptionBond, _Bond);

		function SubscriptionBond(rpc) {
			_classCallCheck(this, SubscriptionBond);

			var _this2 = _possibleConstructorReturn(this, (SubscriptionBond.__proto__ || Object.getPrototypeOf(SubscriptionBond)).call(this));

			api.subscribe(rpc, function (e, n) {
				//			console.log(`Subscription ${rpc} firing ${+n}`)
				_this2.trigger(n);
			}).then(function (id) {
				return _this2.subscription = id;
			});
			return _this2;
		}

		_createClass(SubscriptionBond, [{
			key: 'drop',
			value: function drop() {
				api.unsubscribe(this.subscription);
			}
		}, {
			key: 'map',
			value: function map(f) {
				return new TransformBond(f, [this]);
			}
		}, {
			key: 'sub',
			value: function sub(name) {
				return new TransformBond(function (r, n) {
					return r[n];
				}, [this, name]);
			}
		}], [{
			key: 'all',
			value: function all(list) {
				return new TransformBond(function () {
					for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						args[_key2] = arguments[_key2];
					}

					return args;
				}, list);
			}
		}]);

		return SubscriptionBond;
	}(_oo.Bond);

	var Signature = function (_ReactivePromise) {
		_inherits(Signature, _ReactivePromise);

		function Signature(from, message) {
			var _this3;

			_classCallCheck(this, Signature);

			return _this3 = _possibleConstructorReturn(this, (Signature.__proto__ || Object.getPrototypeOf(Signature)).call(this, [from, message], [], function (_ref) {
				var _ref2 = _slicedToArray(_ref, 2),
				    from = _ref2[0],
				    message = _ref2[1];

				api.parity.postSign(from, api.util.asciiToHex(message)).then(function (signerRequestId) {
					_this3.trigger({ requested: signerRequestId });
					return api.pollMethod('parity_checkRequest', signerRequestId);
				}).then(function (signature) {
					_this3.trigger({ signed: signature });
				}).catch(function (error) {
					_this3.trigger({ failed: error });
				});
			}));
		}

		return Signature;
	}(_oo.ReactivePromise);

	var Transaction = function (_ReactivePromise2) {
		_inherits(Transaction, _ReactivePromise2);

		function Transaction(tx) {
			var _this4;

			_classCallCheck(this, Transaction);

			return _this4 = _possibleConstructorReturn(this, (Transaction.__proto__ || Object.getPrototypeOf(Transaction)).call(this, [tx], [], function (_ref3) {
				var _ref4 = _slicedToArray(_ref3, 1),
				    tx = _ref4[0];

				var progress = _this4.trigger.bind(_this4);
				progress({ estimating: null });
				var from = tx.from || bonds.defaultAccount;
				var gasPrice = tx.gasPrice || bonds.gasPrice;
				var gas = tx.gas || bonds.estimateGas({
					value: tx.value,
					from: tx.from || bonds.defaultAccount,
					to: tx.to,
					gasPrice: tx.gasPrice || bonds.gasPrice,
					data: tx.data
				});
				new _oo.ReactivePromise([from, gasPrice, gas], [], function (_ref5) {
					var _ref6 = _slicedToArray(_ref5, 3),
					    from = _ref6[0],
					    gasPrice = _ref6[1],
					    gas = _ref6[2];

					console.log('Finally posting ' + JSON.stringify(tx) + ' with gas: ' + gas + ', gasPrice: ' + gasPrice + ', from: ' + from);
					tx.gas = gas;
					tx.gasPrice = gasPrice;
					tx.from = from;
					api.parity.postTransaction(tx).then(function (signerRequestId) {
						progress({ requested: signerRequestId });
						return api.pollMethod('parity_checkRequest', signerRequestId);
					}).then(function (transactionHash) {
						progress({ signed: transactionHash });
						return api.pollMethod('eth_getTransactionReceipt', transactionHash, function (receipt) {
							return receipt && receipt.blockNumber && !receipt.blockNumber.eq(0);
						});
					}).then(function (receipt) {
						progress({ confirmed: receipt });
					}).catch(function (error) {
						progress({ failed: error });
					});
				});
			}));
		}

		return Transaction;
	}(_oo.ReactivePromise);

	function overlay(base, top) {
		Object.keys(top).forEach(function (k) {
			base[k] = top[k];
		});
		return base;
	}

	function call(addr, method, args, options) {
		var data = api.util.abiEncode(method.name, method.inputs.map(function (f) {
			return f.type;
		}), args);
		var decode = function decode(d) {
			return api.util.abiDecode(method.outputs.map(function (f) {
				return f.type;
			}), d);
		};
		return api.eth.call(overlay({ to: addr, data: data }, options)).then(decode);
	};

	function post(addr, method, args, options) {
		var toOptions = function toOptions(addr, method, options) {
			for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
				args[_key3 - 3] = arguments[_key3];
			}

			return overlay({ to: addr, data: api.util.abiEncode(method.name, method.inputs.map(function (f) {
					return f.type;
				}), args) }, options);
		};
		return new bonds.Transaction(toOptions.bond.apply(toOptions, [addr, method, options].concat(_toConsumableArray(args))));
	};

	bonds.Transaction = Transaction;
	bonds.Signature = Signature;
	bonds.Subscription = SubscriptionBond;
	bonds.Transform = TransformBond;
	bonds.time = new _oo.TimeBond();
	bonds.blockNumber = new TransformBond(function (_) {
		return +_;
	}, [new SubscriptionBond('eth_blockNumber')]);
	//	bonds.accounts = new SubscriptionBond('eth_accounts').subscriptable();
	//	bonds.accountsInfo = new SubscriptionBond('parity_accountsInfo').subscriptable();
	//	bonds.defaultAccount = new SubscriptionBond('parity_defaultAccount').subscriptable();
	//	bonds.allAccountsInfo = new SubscriptionBond('parity_allAccountsInfo');
	//	bonds.requestsToConfirm = new SubscriptionBond('signer_requestsToConfirm');

	Function.__proto__.bond = function () {
		for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
			args[_key4] = arguments[_key4];
		}

		return new TransformBond(this, args);
	};
	Function.__proto__.unlatchedBond = function () {
		for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
			args[_key5] = arguments[_key5];
		}

		return new TransformBond(this, args, [], false, undefined);
	};
	Function.__proto__.timeBond = function () {
		for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
			args[_key6] = arguments[_key6];
		}

		return new TransformBond(this, args, [bonds.time]);
	};
	Function.__proto__.blockBond = function () {
		for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
			args[_key7] = arguments[_key7];
		}

		return new TransformBond(this, args, [bonds.blockNumber]);
	};

	var presub = function presub(f) {
		return new Proxy(f, {
			get: function get(receiver, name) {
				if (typeof name === 'string' || typeof name === 'number') {
					return typeof receiver[name] !== 'undefined' ? receiver[name] : receiver(name);
				} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol' && _oo.Bond.knowSymbol(name)) {
					return receiver(_oo.Bond.fromSymbol(name));
				} else {
					throw 'Weird value type to be subscripted by: ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + ': ' + JSON.stringify(name);
				}
			}
		});
	};

	// eth_
	bonds.blockByNumber = function (x) {
		return new TransformBond(api.eth.getBlockByNumber, [x], [/* TODO: chain reorg that includes number x */]).subscriptable();
	};
	bonds.blockByHash = function (x) {
		return new TransformBond(api.eth.getBlockByHash, [x]).subscriptable();
	};
	bonds.blockByX = function (x) {
		return new TransformBond(function (n) {
			return typeof n === 'number' || typeof n === 'string' && n.match(/^[0-9]+$/) ? api.eth.getBlockByNumber(x) : api.eth.getBlockByHash(x);
		}, [x], [/* TODO: chain reorg that includes number x, if x is a number */]).subscriptable();
	};
	bonds.blocks = presub(bonds.blockByX);
	bonds.block = bonds.blockByNumber(bonds.blockNumber);
	bonds.coinbase = new TransformBond(api.eth.coinbase, [], [bonds.time]);
	bonds.accounts = new TransformBond(function (a) {
		return a.map(api.util.toChecksumAddress);
	}, [new TransformBond(api.eth.accounts, [], [bonds.time])]).subscriptable();
	bonds.defaultAccount = bonds.accounts[0]; // TODO: make this use its subscription

	bonds.balance = function (x) {
		return new TransformBond(api.eth.getBalance, [x], [bonds.blockNumber]);
	};
	bonds.code = function (x) {
		return new TransformBond(api.eth.getCode, [x], [bonds.blockNumber]);
	};
	bonds.transactionCount = function (x) {
		return new TransformBond(api.eth.getTransactionCount, [x], [bonds.blockNumber]);
	};
	bonds.storageAt = function (x, y) {
		return new TransformBond(api.eth.getStorageAt, [x, y], [bonds.blockNumber]);
	};

	bonds.syncing = new TransformBond(api.eth.syncing, [], [bonds.time]);
	bonds.hashrate = new TransformBond(api.eth.hashrate, [], [bonds.time]);
	bonds.mining = new TransformBond(api.eth.mining, [], [bonds.time]);
	bonds.protocolVersion = new TransformBond(api.eth.protocolVersion, [], [bonds.time]);
	bonds.gasPrice = new TransformBond(api.eth.gasPrice, [], [bonds.time]);
	bonds.estimateGas = function (x) {
		return new TransformBond(api.eth.estimateGas, [x], [bonds.blockNumber]);
	};

	// Weird compound

	// net_
	bonds.peerCount = new TransformBond(api.net.peerCount, [], [bonds.time]);

	// parity_
	bonds.hashContent = function (u) {
		return new TransformBond(api.parity.hashContent, [u], [], false);
	};
	bonds.netChain = new TransformBond(api.parity.netChain, [], [bonds.time]);
	bonds.accountsInfo = new TransformBond(api.parity.accountsInfo, [], [bonds.time]).subscriptable(2); //new SubscriptionBond('parity_accountsInfo');

	bonds.makeContract = function (address, abi) {
		var extras = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

		var r = { address: address };
		var unwrapIfOne = function unwrapIfOne(a) {
			return a.length == 1 ? a[0] : a;
		};
		abi.forEach(function (i) {
			if (i.type == 'function' && i.constant) {
				var f = function f() {
					for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
						args[_key8] = arguments[_key8];
					}

					var options = args.length === i.inputs.length + 1 ? args.unshift() : {};
					if (args.length != i.inputs.length) throw 'Invalid number of arguments to ' + i.name + '. Expected ' + i.inputs.length + ', got ' + args.length + '.';
					var f = function f(addr) {
						for (var _len9 = arguments.length, fargs = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
							fargs[_key9 - 1] = arguments[_key9];
						}

						return call(addr, i, fargs, options).then(unwrapIfOne);
					};
					return new TransformBond(f, [address].concat(args), [bonds.blockNumber]).subscriptable(); // TODO: should be subscription on contract events
				};
				r[i.name] = i.inputs.length === 1 ? presub(f) : f;
			}
		});
		extras.forEach(function (i) {
			var f = function f() {
				for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
					args[_key10] = arguments[_key10];
				}

				var expectedInputs = i.numInputs || i.args.length;
				var options = args.length === expectedInputs + 1 ? args.unshift() : {};
				if (args.length != expectedInputs) throw 'Invalid number of arguments to ' + i.name + '. Expected ' + expectedInputs + ', got ' + args.length + '.';
				var c = abi.find(function (j) {
					return j.name == i.method;
				});
				var f = function f(addr) {
					for (var _len11 = arguments.length, fargs = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
						fargs[_key11 - 1] = arguments[_key11];
					}

					var args = i.args.map(function (v, index) {
						return v === null ? fargs[index] : typeof v === 'function' ? v(fargs[index]) : v;
					});
					return call(addr, c, args, options).then(unwrapIfOne);
				};
				return new TransformBond(f, [address].concat(args), [bonds.blockNumber]).subscriptable(); // TODO: should be subscription on contract events
			};
			r[i.name] = i.args.length === 1 ? presub(f) : f;
		});
		abi.forEach(function (i) {
			if (i.type == 'function' && !i.constant) {
				r[i.name] = function () {
					for (var _len12 = arguments.length, args = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
						args[_key12] = arguments[_key12];
					}

					var options = args.length === i.inputs.length + 1 ? args.pop() : {};
					if (args.length !== i.inputs.length) throw 'Invalid number of arguments to ' + i.name + '. Expected ' + i.inputs.length + ', got ' + args.length + '.';
					return post(address, i, args, options).subscriptable();
				};
			}
		});
		var eventLookup = {};
		abi.filter(function (i) {
			return i.type == 'event';
		}).forEach(function (i) {
			eventLookup[api.util.abiSig(i.name, i.inputs.map(function (f) {
				return f.type;
			}))] = i.name;
		});

		abi.forEach(function (i) {
			if (i.type == 'event') {
				r[i.name] = function () {
					var indexed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
					var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

					return new TransformBond(function (addr, indexed) {
						var topics = [api.util.abiSig(i.name, i.inputs.map(function (f) {
							return f.type;
						}))];
						i.inputs.filter(function (f) {
							return f.indexed;
						}).forEach(function (f) {
							var val = null;
							if (indexed[f.name]) {
								if (f.type == 'string' || f.type == 'bytes') {
									val = api.util.sha3(indexed[f.name]);
								} else {
									val = api.util.abiEncode(null, [f.type], [indexed[f.name]]);
								}
								if (val.length != 66) {
									console.warn('Couldn\'t encode indexed parameter ' + f.name + ' of type ' + f.type + ' with value ' + indexed[f.name]);
									val = null;
								}
							}
							topics.push(val);
						});
						return api.eth.getLogs({
							address: addr,
							fromBlock: params.fromBlock || 0,
							toBlock: params.toBlock || 'pending',
							limit: params.limit || 10,
							topics: topics
						}).then(function (logs) {
							return logs.map(function (l) {
								l.blockNumber = +l.blockNumber;
								l.transactionIndex = +l.transactionIndex;
								l.logIndex = +l.logIndex;
								l.transactionLogIndex = +l.transactionLogIndex;
								var e = {};
								var unins = i.inputs.filter(function (f) {
									return !f.indexed;
								});
								api.util.abiDecode(unins.map(function (f) {
									return f.type;
								}), l.data).forEach(function (v, j) {
									var f = unins[j];
									if (v instanceof Array && !f.type.endsWith(']')) {
										v = api.util.bytesToHex(v);
									}
									if (f.type.substr(0, 4) == 'uint' && +f.type.substr(4) <= 48) {
										v = +v;
									}
									e[f.name] = v;
								});
								i.inputs.filter(function (f) {
									return f.indexed;
								}).forEach(function (f, j) {
									if (f.type == 'string' || f.type == 'bytes') {
										l.args[f.name] = l.topics[1 + j];
									} else {
										var v = api.util.abiDecode([f.type], l.topics[1 + j])[0];
										if (v instanceof Array) {
											v = api.util.bytesToHex(v);
										}
										if (f.type.substr(0, 4) == 'uint' && +f.type.substr(4) <= 48) {
											v = +v;
										}
										e[f.name] = v;
									}
								});
								e.event = eventLookup[l.topics[0]];
								e.log = l;
								return e;
							});
						});
					}, [address, indexed], [bonds.blockNumber]).subscriptable();
				};
			}
		});
		return r;
	};

	bonds.registry = bonds.makeContract(new TransformBond(api.parity.registryAddress, [], [bonds.time]), api.abi.registry, api.abi.registryExtras); // TODO should be subscription.
	bonds.githubhint = bonds.makeContract(bonds.registry.lookupAddress('githubhint', 'A'), api.abi.githubhint);
	bonds.operations = bonds.makeContract(bonds.registry.lookupAddress('operations', 'A'), api.abi.operations);

	return bonds;
}

////
// Parity Utilities

// TODO: move to parity.js, repackage or repot.

function capitalizeFirstLetter(s) {
	return s.charAt(0).toUpperCase() + s.slice(1);
}

function singleton(f) {
	var instance = null;
	return function () {
		if (instance === null) instance = f();
		return instance;
	};
}

var denominations = exports.denominations = ["wei", "Kwei", "Mwei", "Gwei", "szabo", "finney", "ether", "grand", "Mether", "Gether", "Tether", "Pether", "Eether", "Zether", "Yether", "Nether", "Dether", "Vether", "Uether"];

function denominationMultiplier(s) {
	var i = denominations.indexOf(s);
	if (i < 0) throw "Invalid denomination";
	return new _bignumber2.default(1000).pow(i);
}

function interpretQuantity(s) {
	try {
		var m = s.toLowerCase().match('([0-9,.]+) *([a-zA-Z]+)?');
		var d = denominationMultiplier(m[2] || 'ether');
		var n = +m[1].replace(',', '');
		while (n !== Math.round(n)) {
			n *= 10;
			d = d.div(10);
		}
		return new _bignumber2.default(n).mul(d);
	} catch (e) {
		return null;
	}
}

function splitValue(a) {
	var i = 0;
	var a = new _bignumber2.default('' + a);
	if (a.gte(new _bignumber2.default("10000000000000000")) && a.lt(new _bignumber2.default("100000000000000000000000")) || a.eq(0)) i = 6;else for (var aa = a; aa.gte(1000) && i < denominations.length - 1; aa = aa.div(1000)) {
		i++;
	}for (var j = 0; j < i; ++j) {
		a = a.div(1000);
	}return { base: a, denom: i };
}

function formatBalance(n) {
	var a = splitValue(n);
	var b = Math.floor(a.base * 1000) / 1000;
	return b + ' ' + denominations[a.denom];
}

function formatBlockNumber(n) {
	return '#' + ('' + n).replace(/(\d)(?=(\d{3})+$)/g, "$1,");
}

function isNullData(a) {
	return !a || typeof a !== 'string' || a.match(/^(0x)?0+$/) !== null;
}

exports.abiPolyfill = _abis.abiPolyfill;