'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.denominations = exports.TokenABI = exports.BadgeABI = exports.TokenRegABI = exports.BadgeRegABI = exports.OperationsABI = exports.GitHubHintABI = exports.RegistryExtras = exports.RegistryABI = exports.abiPolyfill = exports.toChecksumAddress = exports.sha3 = exports.isAddressValid = exports.hexToAscii = exports.bytesToHex = exports.asciiToHex = exports.bonds = exports.options = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.setupBonds = setupBonds;
exports.Bonds = Bonds;
exports.capitalizeFirstLetter = capitalizeFirstLetter;
exports.singleton = singleton;
exports.denominationMultiplier = denominationMultiplier;
exports.interpretRender = interpretRender;
exports.combineValue = combineValue;
exports.defDenom = defDenom;
exports.formatValue = formatValue;
exports.formatValueNoDenom = formatValueNoDenom;
exports.interpretQuantity = interpretQuantity;
exports.splitValue = splitValue;
exports.formatBalance = formatBalance;
exports.formatBlockNumber = formatBlockNumber;
exports.isNullData = isNullData;
exports.splitSignature = splitSignature;
exports.removeSigningPrefix = removeSigningPrefix;
exports.cleanup = cleanup;

var _oo = require('oo7');

var _bignumber = require('bignumber.js');

var _bignumber2 = _interopRequireDefault(_bignumber);

var _abis = require('./abis.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Parity = require('@parity/parity.js');

// DEPRECATED. TODO: REMOVE
function setupBonds() {
	var _api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : parity.api;

	return createBonds({ api: _api });
}

function defaultTransport() {
	var transport;

	// Check to see if there's already a parity object injected in window.
	if (window && window.parity && window.parity.api.transport._url) {
		transport = new Parity.Api.Transport.Http(window.parity.api.transport._url[0] === '/' ? window.location.protocol + '//' + window.location.host + window.parity.api.transport._url : window.parity.api.transport._url.contains('://') ? window.parity.api.transport._url : window.location.href + window.parity.api.transport._url);
	}

	// Fallback to localhost:8545
	if (!transport) {
		transport = new Parity.Api.Transport.Http('http://localhost:8545');
	}

	return transport;
}

function Bonds() {
	var transport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultTransport();

	return createBonds({ api: new Parity.Api(transport) });
}

function createBonds(options) {
	var bonds = {};

	// We only ever use api() at call-time of this function; this allows the
	// options (particularly the transport option) to be changed dynamically
	// and the datastructure to be reused.
	var api = function api() {
		return options.api;
	};
	var util = Parity.Api.util;

	// Deprecated - remove once all code moved over to avoid parity.api.abi.
	if (!api().abi) {
		api().abi = (0, _abis.abiPolyfill)();
	}

	var TransformBond = function (_oo7TransformBond) {
		_inherits(TransformBond, _oo7TransformBond);

		function TransformBond(f) {
			var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
			var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
			var outResolveDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
			var resolveDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
			var latched = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
			var mayBeNull = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;

			_classCallCheck(this, TransformBond);

			return _possibleConstructorReturn(this, (TransformBond.__proto__ || Object.getPrototypeOf(TransformBond)).call(this, f, a, d, outResolveDepth, resolveDepth, latched, mayBeNull, api()));
		}

		_createClass(TransformBond, [{
			key: 'map',
			value: function map(f) {
				var outResolveDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
				var resolveDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

				return new TransformBond(f, [this], [], outResolveDepth, resolveDepth);
			}
		}, {
			key: 'sub',
			value: function sub(name) {
				var outResolveDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
				var resolveDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

				return new TransformBond(function (r, n) {
					return r[n];
				}, [this, name], [], outResolveDepth, resolveDepth);
			}
		}], [{
			key: 'all',
			value: function all(list) {
				return new TransformBond(function () {
					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					return args;
				}, list);
			}
		}]);

		return TransformBond;
	}(_oo.TransformBond);

	// TODO: Use more generic means to check on number, ideally push notification.


	var SubscriptionBond = function (_Bond) {
		_inherits(SubscriptionBond, _Bond);

		function SubscriptionBond(rpc) {
			_classCallCheck(this, SubscriptionBond);

			var _this2 = _possibleConstructorReturn(this, (SubscriptionBond.__proto__ || Object.getPrototypeOf(SubscriptionBond)).call(this));

			_this2.rpc = rpc;
			return _this2;
		}

		_createClass(SubscriptionBond, [{
			key: 'initialise',
			value: function initialise() {
				var _this3 = this;

				api().subscribe(this.rpc, function (_, n) {
					return _this3.trigger(n);
				}).then(function (id) {
					return _this3.subscription = id;
				});
			}
		}, {
			key: 'finalise',
			value: function finalise() {
				api().unsubscribe(this.subscription);
			}
		}, {
			key: 'map',
			value: function map(f) {
				return new TransformBond(f, [this]);
			}
		}, {
			key: 'sub',
			value: function sub(name) {
				return new TransformBond(function (r, n) {
					return r[n];
				}, [this, name]);
			}
		}], [{
			key: 'all',
			value: function all(list) {
				return new TransformBond(function () {
					for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
						args[_key2] = arguments[_key2];
					}

					return args;
				}, list);
			}
		}]);

		return SubscriptionBond;
	}(_oo.Bond);

	var Signature = function (_ReactivePromise) {
		_inherits(Signature, _ReactivePromise);

		function Signature(message, from) {
			_classCallCheck(this, Signature);

			var _this4 = _possibleConstructorReturn(this, (Signature.__proto__ || Object.getPrototypeOf(Signature)).call(this, [message, from], [], function (_ref) {
				var _ref2 = _slicedToArray(_ref, 2),
				    message = _ref2[0],
				    from = _ref2[1];

				api().parity.postSign(from, util.asciiToHex(message)).then(function (signerRequestId) {
					_this4.trigger({ requested: signerRequestId });
					return api().pollMethod('parity_checkRequest', signerRequestId);
				}).then(function (signature) {
					_this4.trigger({
						signed: splitSignature(signature)
					});
				}).catch(function (error) {
					console.error(error);
					_this4.trigger({ failed: error });
				});
			}, false));

			_this4.then(function (_) {
				return null;
			});
			return _this4;
		}

		_createClass(Signature, [{
			key: 'isDone',
			value: function isDone(s) {
				return !!s.failed || !!s.signed;
			}
		}]);

		return Signature;
	}(_oo.ReactivePromise);

	function transactionPromise(tx, progress, f) {
		progress({ initialising: null });
		Promise.all([api().eth.accounts(), api().eth.gasPrice()]).then(function (_ref3) {
			var _ref4 = _slicedToArray(_ref3, 2),
			    a = _ref4[0],
			    p = _ref4[1];

			progress({ estimating: null });
			tx.from = tx.from || a[0];
			tx.gasPrice = tx.gasPrice || p;
			return api().eth.estimateGas(tx);
		}).then(function (g) {
			progress({ estimated: g });
			tx.gas = tx.gas || g;
			return api().parity.postTransaction(tx);
		}).then(function (signerRequestId) {
			progress({ requested: signerRequestId });
			return api().pollMethod('parity_checkRequest', signerRequestId);
		}).then(function (transactionHash) {
			progress({ signed: transactionHash });
			return api().pollMethod('eth_getTransactionReceipt', transactionHash, function (receipt) {
				return receipt && receipt.blockNumber && !receipt.blockNumber.eq(0);
			});
		}).then(function (receipt) {
			progress(f({ confirmed: receipt }));
			return receipt;
		}).catch(function (error) {
			progress({ failed: error });
		});
	}

	var Transaction = function (_ReactivePromise2) {
		_inherits(Transaction, _ReactivePromise2);

		function Transaction(tx) {
			_classCallCheck(this, Transaction);

			var _this5 = _possibleConstructorReturn(this, (Transaction.__proto__ || Object.getPrototypeOf(Transaction)).call(this, [tx], [], function (_ref5) {
				var _ref6 = _slicedToArray(_ref5, 1),
				    tx = _ref6[0];

				var progress = _this5.trigger.bind(_this5);
				transactionPromise(tx, progress, function (_) {
					return _;
				});
			}, false));

			_this5.then(function (_) {
				return null;
			});
			return _this5;
		}

		_createClass(Transaction, [{
			key: 'isDone',
			value: function isDone(s) {
				return !!(s.failed || s.confirmed);
			}
		}]);

		return Transaction;
	}(_oo.ReactivePromise);

	function overlay(base, top) {
		Object.keys(top).forEach(function (k) {
			base[k] = top[k];
		});
		return base;
	}

	function memoized(f) {
		var memo;
		return function () {
			if (memo === undefined) memo = f();
			return memo;
		};
	}

	function call(addr, method, args, options) {
		var data = util.abiEncode(method.name, method.inputs.map(function (f) {
			return f.type;
		}), args);
		var decode = function decode(d) {
			return util.abiDecode(method.outputs.map(function (f) {
				return f.type;
			}), d);
		};
		return api().eth.call(overlay({ to: addr, data: data }, options)).then(decode);
	};

	function post(addr, method, args, options) {
		var toOptions = function toOptions(addr, method, options) {
			for (var _len3 = arguments.length, args = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
				args[_key3 - 3] = arguments[_key3];
			}

			return overlay({ to: addr, data: util.abiEncode(method.name, method.inputs.map(function (f) {
					return f.type;
				}), args) }, options);
		};
		return new Transaction(toOptions.bond.apply(toOptions, [addr, method, options].concat(_toConsumableArray(args))));
	};

	bonds.time = new _oo.TimeBond();
	// TODO: rename `height`
	bonds.blockNumber = new TransformBond(function () {
		return api().eth.blockNumber().then(function (_) {
			return +_;
		});
	}, [], [bonds.time]);
	//	bonds.blockNumber = new TransformBond(_=>+_, [new SubscriptionBond('eth_blockNumber')]);
	//	bonds.accounts = new SubscriptionBond('eth_accounts').subscriptable();
	//	bonds.accountsInfo = new SubscriptionBond('parity_accountsInfo').subscriptable();
	//	bonds.defaultAccount = new SubscriptionBond('parity_defaultAccount').subscriptable();
	//	bonds.allAccountsInfo = new SubscriptionBond('parity_allAccountsInfo');
	//	bonds.requestsToConfirm = new SubscriptionBond('signer_requestsToConfirm');

	Function.__proto__.bond = function () {
		for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
			args[_key4] = arguments[_key4];
		}

		return new TransformBond(this, args);
	};
	Function.__proto__.unlatchedBond = function () {
		for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
			args[_key5] = arguments[_key5];
		}

		return new TransformBond(this, args, [], false, undefined);
	};
	Function.__proto__.timeBond = function () {
		for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
			args[_key6] = arguments[_key6];
		}

		return new TransformBond(this, args, [bonds.time]);
	};
	Function.__proto__.blockBond = function () {
		for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
			args[_key7] = arguments[_key7];
		}

		return new TransformBond(this, args, [bonds.blockNumber]);
	};

	var presub = function presub(f) {
		return new Proxy(f, {
			get: function get(receiver, name) {
				if (typeof name === 'string' || typeof name === 'number') {
					return typeof receiver[name] !== 'undefined' ? receiver[name] : receiver(name);
				} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol' && _oo.Bond.knowSymbol(name)) {
					return receiver(_oo.Bond.fromSymbol(name));
				} else {
					throw 'Weird value type to be subscripted by: ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + ': ' + JSON.stringify(name);
				}
			}
		});
	};

	function isNumber(n) {
		return typeof n === 'number' || typeof n === 'string' && n.match(/^[0-9]+$/);
	}

	var onAccountsChanged = bonds.time; // TODO: more accurate notification
	var onHardwareAccountsChanged = bonds.time; // TODO: more accurate notification
	var onHeadChanged = bonds.blockNumber; // TODO: more accurate notification
	//	let onReorg = undefined;	// TODO make more accurate.
	var onSyncingChanged = bonds.time;
	var onAuthoringDetailsChanged = bonds.time;
	var onPeerNetChanged = bonds.time; // TODO: more accurate notification
	var onPendingChanged = bonds.time; // TODO: more accurate notification
	var onUnsignedChanged = bonds.time; // TODO: more accurate notification
	var onAutoUpdateChanged = bonds.blockNumber;

	// eth_
	bonds.height = bonds.blockNumber;
	bonds.blockByNumber = function (x) {
		return new TransformBond(function (x) {
			return api().eth.getBlockByNumber(x);
		}, [x], []).subscriptable();
	}; // TODO: chain reorg that includes number x
	bonds.blockByHash = function (x) {
		return new TransformBond(function (x) {
			return api().eth.getBlockByHash(x);
		}, [x]).subscriptable();
	};
	bonds.findBlock = function (hashOrNumberBond) {
		return new TransformBond(function (hashOrNumber) {
			return isNumber(hashOrNumber) ? api().eth.getBlockByNumber(hashOrNumber) : api().eth.getBlockByHash(hashOrNumber);
		}, [hashOrNumberBond], [/*onReorg*/]).subscriptable();
	}; // TODO: chain reorg that includes number x, if x is a number
	bonds.blocks = presub(bonds.findBlock);
	bonds.block = bonds.blockByNumber(bonds.blockNumber); // TODO: DEPRECATE AND REMOVE
	bonds.head = new TransformBond(function () {
		return api().eth.getBlockByNumber('latest');
	}, [], [onHeadChanged]).subscriptable(); // TODO: chain reorgs
	bonds.author = new TransformBond(function () {
		return api().eth.coinbase();
	}, [], [onAccountsChanged]);
	bonds.accounts = new TransformBond(function (a) {
		return a.map(util.toChecksumAddress);
	}, [new TransformBond(function () {
		return api().eth.accounts();
	}, [], [onAccountsChanged])]).subscriptable();
	bonds.defaultAccount = bonds.accounts[0]; // TODO: make this use its subscription
	bonds.me = bonds.accounts[0];
	bonds.post = function (tx) {
		return new Transaction(tx);
	};
	bonds.sign = function (message) {
		var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : bonds.me;
		return new Signature(message, from);
	};

	bonds.balance = function (x) {
		return new TransformBond(function (x) {
			return api().eth.getBalance(x);
		}, [x], [onHeadChanged]);
	};
	bonds.code = function (x) {
		return new TransformBond(function (x) {
			return api().eth.getCode(x);
		}, [x], [onHeadChanged]);
	};
	bonds.nonce = function (x) {
		return new TransformBond(function (x) {
			return api().eth.getTransactionCount(x).then(function (_) {
				return +_;
			});
		}, [x], [onHeadChanged]);
	};
	bonds.storageAt = function (x, y) {
		return new TransformBond(function (x, y) {
			return api().eth.getStorageAt(x, y);
		}, [x, y], [onHeadChanged]);
	};

	bonds.syncing = new TransformBond(function () {
		return api().eth.syncing();
	}, [], [onSyncingChanged]);
	bonds.hashrate = new TransformBond(function () {
		return api().eth.hashrate();
	}, [], [onAuthoringDetailsChanged]);
	bonds.authoring = new TransformBond(function () {
		return api().eth.mining();
	}, [], [onAuthoringDetailsChanged]);
	bonds.ethProtocolVersion = new TransformBond(function () {
		return api().eth.protocolVersion();
	}, [], []);
	bonds.gasPrice = new TransformBond(function () {
		return api().eth.gasPrice();
	}, [], [onHeadChanged]);
	bonds.estimateGas = function (x) {
		return new TransformBond(function (x) {
			return api().eth.estimateGas(x);
		}, [x], [onHeadChanged, onPendingChanged]);
	};

	bonds.blockTransactionCount = function (hashOrNumberBond) {
		return new TransformBond(function (hashOrNumber) {
			return isNumber(hashOrNumber) ? api().eth.getBlockTransactionCountByNumber(hashOrNumber).then(function (_) {
				return +_;
			}) : api().eth.getBlockTransactionCountByHash(hashOrNumber).then(function (_) {
				return +_;
			});
		}, [hashOrNumberBond], [/*onReorg*/]);
	};
	bonds.uncleCount = function (hashOrNumberBond) {
		return new TransformBond(function (hashOrNumber) {
			return isNumber(hashOrNumber) ? api().eth.getUncleCountByBlockNumber(hashOrNumber).then(function (_) {
				return +_;
			}) : api().eth.getUncleCountByBlockHash(hashOrNumber).then(function (_) {
				return +_;
			});
		}, [hashOrNumberBond], [/*onReorg*/]).subscriptable();
	};
	bonds.uncle = function (hashOrNumberBond, indexBond) {
		return new TransformBond(function (hashOrNumber, index) {
			return isNumber(hashOrNumber) ? api().eth.getUncleByBlockNumber(hashOrNumber, index) : api().eth.getUncleByBlockHash(hashOrNumber, index);
		}, [hashOrNumberBond, indexBond], [/*onReorg*/]).subscriptable();
	};
	bonds.transaction = function (hashOrNumberBond, indexOrNullBond) {
		return new TransformBond(function (hashOrNumber, indexOrNull) {
			return indexOrNull === undefined || indexOrNull === null ? api().eth.getTransactionByHash(hashOrNumber) : isNumber(hashOrNumber) ? api().eth.getTransactionByBlockNumberAndIndex(hashOrNumber, indexOrNull) : api().eth.getTransactionByBlockHashAndIndex(hashOrNumber, indexOrNull);
		}, [hashOrNumberBond, indexOrNullBond], [/*onReorg*/]).subscriptable();
	};
	bonds.receipt = function (hashBond) {
		return new TransformBond(function (x) {
			return api().eth.getTransactionReceipt(x);
		}, [hashBond], []).subscriptable();
	};

	// web3_
	bonds.clientVersion = new TransformBond(function () {
		return api().web3.clientVersion();
	}, [], []);

	// net_
	bonds.peerCount = new TransformBond(function () {
		return api().net.peerCount().then(function (_) {
			return +_;
		});
	}, [], [onPeerNetChanged]);
	bonds.listening = new TransformBond(function () {
		return api().net.listening();
	}, [], [onPeerNetChanged]);
	bonds.chainId = new TransformBond(function () {
		return api().net.version();
	}, [], []);

	// parity_
	bonds.hashContent = function (u) {
		return new TransformBond(function (x) {
			return api().parity.hashContent(x);
		}, [u], [], false);
	};
	bonds.gasPriceHistogram = new TransformBond(function () {
		return api().parity.gasPriceHistogram();
	}, [], [onHeadChanged]).subscriptable();
	bonds.accountsInfo = new TransformBond(function () {
		return api().parity.accountsInfo();
	}, [], [onAccountsChanged]).subscriptable(2);
	bonds.hardwareAccountsInfo = new TransformBond(function () {
		return api().parity.hardwareAccountsInfo();
	}, [], [onHardwareAccountsChanged]).subscriptable(2);
	bonds.mode = new TransformBond(function () {
		return api().parity.mode();
	}, [], [bonds.blockNumber]);

	// ...authoring
	bonds.defaultExtraData = new TransformBond(function () {
		return api().parity.defaultExtraData();
	}, [], [onAuthoringDetailsChanged]);
	bonds.extraData = new TransformBond(function () {
		return api().parity.extraData();
	}, [], [onAuthoringDetailsChanged]);
	bonds.gasCeilTarget = new TransformBond(function () {
		return api().parity.gasCeilTarget();
	}, [], [onAuthoringDetailsChanged]);
	bonds.gasFloorTarget = new TransformBond(function () {
		return api().parity.gasFloorTarget();
	}, [], [onAuthoringDetailsChanged]);
	bonds.minGasPrice = new TransformBond(function () {
		return api().parity.minGasPrice();
	}, [], [onAuthoringDetailsChanged]);
	bonds.transactionsLimit = new TransformBond(function () {
		return api().parity.transactionsLimit();
	}, [], [onAuthoringDetailsChanged]);

	// ...chain info
	bonds.chainName = new TransformBond(function () {
		return api().parity.netChain();
	}, [], []);
	bonds.chainStatus = new TransformBond(function () {
		return api().parity.chainStatus();
	}, [], [onSyncingChanged]).subscriptable();

	// ...networking
	bonds.peers = new TransformBond(function () {
		return api().parity.netPeers();
	}, [], [onPeerNetChanged]).subscriptable(2);
	bonds.enode = new TransformBond(function () {
		return api().parity.enode();
	}, [], []);
	bonds.nodePort = new TransformBond(function () {
		return api().parity.netPort().then(function (_) {
			return +_;
		});
	}, [], []);
	bonds.nodeName = new TransformBond(function () {
		return api().parity.nodeName();
	}, [], []);
	bonds.signerPort = new TransformBond(function () {
		return api().parity.signerPort().then(function (_) {
			return +_;
		});
	}, [], []);
	bonds.dappsPort = new TransformBond(function () {
		return api().parity.dappsPort().then(function (_) {
			return +_;
		});
	}, [], []);
	bonds.dappsInterface = new TransformBond(function () {
		return api().parity.dappsInterface();
	}, [], []);

	// ...transaction queue
	bonds.nextNonce = new TransformBond(function () {
		return api().parity.nextNonce().then(function (_) {
			return +_;
		});
	}, [], [onPendingChanged]);
	bonds.pending = new TransformBond(function () {
		return api().parity.pendingTransactions();
	}, [], [onPendingChanged]);
	bonds.local = new TransformBond(function () {
		return api().parity.localTransactions();
	}, [], [onPendingChanged]).subscriptable(3);
	bonds.future = new TransformBond(function () {
		return api().parity.futureTransactions();
	}, [], [onPendingChanged]).subscriptable(2);
	bonds.pendingStats = new TransformBond(function () {
		return api().parity.pendingTransactionsStats();
	}, [], [onPendingChanged]).subscriptable(2);
	bonds.unsignedCount = new TransformBond(function () {
		return api().parity.parity_unsignedTransactionsCount().then(function (_) {
			return +_;
		});
	}, [], [onUnsignedChanged]);

	// ...auto-update
	bonds.releasesInfo = new TransformBond(function () {
		return api().parity.releasesInfo();
	}, [], [onAutoUpdateChanged]).subscriptable();
	bonds.versionInfo = new TransformBond(function () {
		return api().parity.versionInfo();
	}, [], [onAutoUpdateChanged]).subscriptable();
	bonds.consensusCapability = new TransformBond(function () {
		return api().parity.consensusCapability();
	}, [], [onAutoUpdateChanged]);
	bonds.upgradeReady = new TransformBond(function () {
		return api().parity.upgradeReady();
	}, [], [onAutoUpdateChanged]).subscriptable();

	var DeployContract = function (_ReactivePromise3) {
		_inherits(DeployContract, _ReactivePromise3);

		function DeployContract(initBond, abiBond, optionsBond) {
			_classCallCheck(this, DeployContract);

			var _this6 = _possibleConstructorReturn(this, (DeployContract.__proto__ || Object.getPrototypeOf(DeployContract)).call(this, [initBond, abiBond, optionsBond, bonds.registry], [], function (_ref7) {
				var _ref8 = _slicedToArray(_ref7, 4),
				    init = _ref8[0],
				    abi = _ref8[1],
				    options = _ref8[2],
				    registry = _ref8[3];

				options.data = init;
				delete options.to;
				var progress = _this6.trigger.bind(_this6);
				transactionPromise(options, progress, function (status) {
					if (status.confirmed) {
						status.deployed = bonds.makeContract(status.confirmed.contractAddress, abi, options.extras || []);
					}
					return status;
				});
				// TODO: consider allowing registry of the contract here.
			}, false));

			_this6.then(function (_) {
				return null;
			});
			return _this6;
		}

		_createClass(DeployContract, [{
			key: 'isDone',
			value: function isDone(s) {
				return !!(s.failed || s.confirmed);
			}
		}]);

		return DeployContract;
	}(_oo.ReactivePromise);

	bonds.deployContract = function (init, abi) {
		var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

		return new DeployContract(init, abi, options);
	};

	bonds.makeContract = function (address, abi) {
		var extras = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

		var r = { address: address };
		var unwrapIfOne = function unwrapIfOne(a) {
			return a.length == 1 ? a[0] : a;
		};
		abi.forEach(function (i) {
			if (i.type == 'function' && i.constant) {
				var f = function f() {
					for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
						args[_key8] = arguments[_key8];
					}

					var options = args.length === i.inputs.length + 1 ? args.unshift() : {};
					if (args.length != i.inputs.length) throw 'Invalid number of arguments to ' + i.name + '. Expected ' + i.inputs.length + ', got ' + args.length + '.';
					var f = function f(addr) {
						for (var _len9 = arguments.length, fargs = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
							fargs[_key9 - 1] = arguments[_key9];
						}

						return call(addr, i, fargs, options).then(function (rets) {
							return rets.map(function (r, o) {
								return cleanup(r, i.outputs[o].type, api);
							});
						}).then(unwrapIfOne);
					};
					return new TransformBond(f, [address].concat(args), [bonds.blockNumber]).subscriptable(); // TODO: should be subscription on contract events
				};
				r[i.name] = i.inputs.length === 0 ? memoized(f) : i.inputs.length === 1 ? presub(f) : f;
			}
		});
		extras.forEach(function (i) {
			var f = function f() {
				for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
					args[_key10] = arguments[_key10];
				}

				var expectedInputs = i.numInputs || i.args.length;
				var options = args.length === expectedInputs + 1 ? args.unshift() : {};
				if (args.length != expectedInputs) throw 'Invalid number of arguments to ' + i.name + '. Expected ' + expectedInputs + ', got ' + args.length + '.';
				var c = abi.find(function (j) {
					return j.name == i.method;
				});
				var f = function f(addr) {
					for (var _len11 = arguments.length, fargs = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
						fargs[_key11 - 1] = arguments[_key11];
					}

					var args = i.args.map(function (v, index) {
						return v === null ? fargs[index] : typeof v === 'function' ? v(fargs[index]) : v;
					});
					return call(addr, c, args, options).then(unwrapIfOne);
				};
				return new TransformBond(f, [address].concat(args), [bonds.blockNumber]).subscriptable(); // TODO: should be subscription on contract events
			};
			r[i.name] = i.args.length === 1 ? presub(f) : f;
		});
		abi.forEach(function (i) {
			if (i.type == 'function' && !i.constant) {
				r[i.name] = function () {
					for (var _len12 = arguments.length, args = Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
						args[_key12] = arguments[_key12];
					}

					var options = args.length === i.inputs.length + 1 ? args.pop() : {};
					if (args.length !== i.inputs.length) throw 'Invalid number of arguments to ' + i.name + '. Expected ' + i.inputs.length + ', got ' + args.length + '.';
					return post(address, i, args, options).subscriptable();
				};
			}
		});
		var eventLookup = {};
		abi.filter(function (i) {
			return i.type == 'event';
		}).forEach(function (i) {
			eventLookup[util.abiSignature(i.name, i.inputs.map(function (f) {
				return f.type;
			}))] = i.name;
		});

		function prepareIndexEncode(v, t) {
			var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

			if (v instanceof Array) {
				if (top) {
					return v.map(function (x) {
						return prepareIndexEncode(x, t, false);
					});
				} else {
					throw 'Invalid type';
				}
			}
			var val;
			if (t == 'string' || t == 'bytes') {
				val = util.sha3(v);
			} else {
				val = util.abiEncode(null, [t], [v]);
			}
			if (val.length != 66) {
				throw 'Invalid length';
			}
			return val;
		}

		abi.forEach(function (i) {
			if (i.type == 'event') {
				r[i.name] = function () {
					var indexed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
					var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

					return new TransformBond(function (addr, indexed) {
						var topics = [util.abiSignature(i.name, i.inputs.map(function (f) {
							return f.type;
						}))];
						i.inputs.filter(function (f) {
							return f.indexed;
						}).forEach(function (f) {
							try {
								topics.push(indexed[f.name] ? prepareIndexEncode(indexed[f.name], f.type) : null);
							} catch (e) {
								throw 'Couldn\'t encode indexed parameter ' + f.name + ' of type ' + f.type + ' with value ' + indexed[f.name];
							}
						});
						return api().eth.getLogs({
							address: addr,
							fromBlock: params.fromBlock || 0,
							toBlock: params.toBlock || 'pending',
							limit: params.limit || 10,
							topics: topics
						}).then(function (logs) {
							return logs.map(function (l) {
								l.blockNumber = +l.blockNumber;
								l.transactionIndex = +l.transactionIndex;
								l.logIndex = +l.logIndex;
								l.transactionLogIndex = +l.transactionLogIndex;
								var e = {};
								var unins = i.inputs.filter(function (f) {
									return !f.indexed;
								});
								util.abiDecode(unins.map(function (f) {
									return f.type;
								}), l.data).forEach(function (v, j) {
									var f = unins[j];
									if (v instanceof Array && !f.type.endsWith(']')) {
										v = util.bytesToHex(v);
									}
									if (f.type.substr(0, 4) == 'uint' && +f.type.substr(4) <= 48) {
										v = +v;
									}
									e[f.name] = v;
								});
								i.inputs.filter(function (f) {
									return f.indexed;
								}).forEach(function (f, j) {
									if (f.type == 'string' || f.type == 'bytes') {
										e[f.name] = l.topics[1 + j];
									} else {
										var v = util.abiDecode([f.type], l.topics[1 + j])[0];
										if (v instanceof Array) {
											v = util.bytesToHex(v);
										}
										if (f.type.substr(0, 4) == 'uint' && +f.type.substr(4) <= 48) {
											v = +v;
										}
										e[f.name] = v;
									}
								});
								e.event = eventLookup[l.topics[0]];
								e.log = l;
								return e;
							});
						});
					}, [address, indexed], [bonds.blockNumber]).subscriptable();
				};
			}
		});
		return r;
	};

	bonds.registry = bonds.makeContract(new TransformBond(function () {
		return api().parity.registryAddress();
	}, [], [bonds.time]), _abis.RegistryABI, _abis.RegistryExtras); // TODO should be subscription.
	bonds.githubhint = bonds.makeContract(bonds.registry.lookupAddress('githubhint', 'A'), _abis.GitHubHintABI);
	bonds.operations = bonds.makeContract(bonds.registry.lookupAddress('operations', 'A'), _abis.OperationsABI);
	bonds.badgereg = bonds.makeContract(bonds.registry.lookupAddress('badgereg', 'A'), _abis.BadgeRegABI);
	bonds.tokenreg = bonds.makeContract(bonds.registry.lookupAddress('tokenreg', 'A'), _abis.TokenRegABI);

	bonds.badges = new TransformBond(function (n) {
		var ret = [];

		var _loop = function _loop() {
			var id = i;
			ret.push(_oo.Bond.all([bonds.badgereg.badge(id), bonds.badgereg.meta(id, 'IMG'), bonds.badgereg.meta(id, 'CAPTION')]).map(function (_ref9) {
				var _ref10 = _slicedToArray(_ref9, 3),
				    _ref10$ = _slicedToArray(_ref10[0], 3),
				    addr = _ref10$[0],
				    name = _ref10$[1],
				    owner = _ref10$[2],
				    img = _ref10[1],
				    caption = _ref10[2];

				return {
					id: id,
					name: name,
					img: img,
					caption: caption,
					badge: bonds.makeContract(addr, _abis.BadgeABI)
				};
			}));
		};

		for (var i = 0; i < +n; ++i) {
			_loop();
		}
		return ret;
	}, [bonds.badgereg.badgeCount()], [], 1);

	bonds.badgesOf = function (address) {
		return new TransformBond(function (addr, bads) {
			return bads.map(function (b) {
				return {
					certified: b.badge.certified(addr),
					badge: b.badge,
					id: b.id,
					img: b.img,
					caption: b.caption,
					name: b.name
				};
			});
		}, [address, bonds.badges], [], 2).map(function (all) {
			return all.filter(function (_) {
				return _.certified;
			});
		});
	};

	bonds.namesOf = function (address) {
		return new TransformBond(function (reg, addr, accs) {
			return {
				owned: accs[addr] ? accs[addr].name : null,
				registry: reg || null
			};
		}, [bonds.registry.reverse(address), address, bonds.accountsInfo]);
	};

	bonds.registry.names = _oo.Bond.mapAll([bonds.registry.ReverseConfirmed({}, { limit: 100 }), bonds.accountsInfo], function (reg, info) {
		var r = {};
		Object.keys(info).forEach(function (k) {
			return r[k] = info[k].name;
		});
		reg.forEach(function (a) {
			return r[a.reverse] = bonds.registry.reverse(a.reverse);
		});
		return r;
	}, 1);

	return bonds;
}

var options = exports.options = { api: new Parity.Api(defaultTransport()) };
var bonds = exports.bonds = createBonds(options);

var asciiToHex = exports.asciiToHex = Parity.Api.util.asciiToHex;
var bytesToHex = exports.bytesToHex = Parity.Api.util.bytesToHex;
var hexToAscii = exports.hexToAscii = Parity.Api.util.hexToAscii;
var isAddressValid = exports.isAddressValid = Parity.Api.util.isAddressValid;
var sha3 = exports.sha3 = Parity.Api.util.sha3;
var toChecksumAddress = exports.toChecksumAddress = Parity.Api.util.toChecksumAddress;

// Deprecated.
exports.abiPolyfill = _abis.abiPolyfill;
exports.RegistryABI = _abis.RegistryABI;
exports.RegistryExtras = _abis.RegistryExtras;
exports.GitHubHintABI = _abis.GitHubHintABI;
exports.OperationsABI = _abis.OperationsABI;
exports.BadgeRegABI = _abis.BadgeRegABI;
exports.TokenRegABI = _abis.TokenRegABI;
exports.BadgeABI = _abis.BadgeABI;
exports.TokenABI = _abis.TokenABI;

////
// Parity Utilities

// TODO: move to parity.js, repackage or repot.

function capitalizeFirstLetter(s) {
	return s.charAt(0).toUpperCase() + s.slice(1);
}

function singleton(f) {
	var instance = null;
	return function () {
		if (instance === null) instance = f();
		return instance;
	};
}

var denominations = exports.denominations = ["wei", "Kwei", "Mwei", "Gwei", "szabo", "finney", "ether", "grand", "Mether", "Gether", "Tether", "Pether", "Eether", "Zether", "Yether", "Nether", "Dether", "Vether", "Uether"];

function denominationMultiplier(s) {
	var i = denominations.indexOf(s);
	if (i < 0) throw "Invalid denomination";
	return new _bignumber2.default(1000).pow(i);
}

function interpretRender(s) {
	var defaultDenom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;

	try {
		var m = s.toLowerCase().match(/([0-9,]+)(\.([0-9]*))? *([a-zA-Z]+)?/);
		var di = m[4] ? denominations.indexOf(m[4]) : defaultDenom;
		if (di === -1) {
			return null;
		}
		var n = m[1].replace(',', '').replace(/^0*/, '') || '0';
		var d = (m[3] || '').replace(/0*$/, '');
		return { denom: di, units: n, decimals: d, origNum: m[1] + (m[2] || ''), origDenom: m[4] || '' };
	} catch (e) {
		return null;
	}
}

function combineValue(v) {
	var d = new _bignumber2.default(1000).pow(v.denom);
	var n = v.units;
	if (v.decimals) {
		n += v.decimals;
		d = d.div(new _bignumber2.default(10).pow(v.decimals.length));
	}
	return new _bignumber2.default(n).mul(d);
}

function defDenom(v, d) {
	if (v.denom === null) {
		v.denom = d;
	}
	return v;
}

function formatValue(n) {
	return formatValueNoDenom(n) + ' ' + denominations[n.denom];
}

function formatValueNoDenom(n) {
	return '' + n.units.toString().replace(/(\d)(?=(\d{3})+$)/g, "$1,") + (n.decimals ? '.' + n.decimals : '');
}

function interpretQuantity(s) {
	try {
		var m = s.toLowerCase().match(/([0-9,]+)(\.([0-9]*))? *([a-zA-Z]+)?/);
		var d = denominationMultiplier(m[4] || 'ether');
		var n = +m[1].replace(',', '');
		if (m[2]) {
			n += m[3];
			for (var i = 0; i < m[3].length; ++i) {
				d = d.div(10);
			}
		}
		return new _bignumber2.default(n).mul(d);
	} catch (e) {
		return null;
	}
}

function splitValue(a) {
	var i = 0;
	var a = new _bignumber2.default('' + a);
	if (a.gte(new _bignumber2.default("10000000000000000")) && a.lt(new _bignumber2.default("100000000000000000000000")) || a.eq(0)) i = 6;else for (var aa = a; aa.gte(1000) && i < denominations.length - 1; aa = aa.div(1000)) {
		i++;
	}for (var j = 0; j < i; ++j) {
		a = a.div(1000);
	}return { base: a, denom: i };
}

function formatBalance(n) {
	var a = splitValue(n);
	//	let b = Math.floor(a.base * 1000) / 1000;
	return a.base + ' ' + denominations[a.denom];
}

function formatBlockNumber(n) {
	return '#' + ('' + n).replace(/(\d)(?=(\d{3})+$)/g, "$1,");
}

function isNullData(a) {
	return !a || typeof a !== 'string' || a.match(/^(0x)?0+$/) !== null;
}

function splitSignature(sig) {
	if ((sig.substr(2, 2) === '1b' || sig.substr(2, 2) === '1c') && sig.substr(66, 2) !== '1b' && sig.substr(66, 2) !== '1c') {
		// vrs
		return [sig.substr(0, 4), '0x' + sig.substr(4, 64), '0x' + sig.substr(68, 64)];
	} else {
		// rsv
		return ['0x' + sig.substr(130, 2), '0x' + sig.substr(2, 64), '0x' + sig.substr(66, 64)];
	}
};

function removeSigningPrefix(message) {
	if (!message.startsWith('\x19Ethereum Signed Message:\n')) {
		throw 'Invalid message - doesn\'t contain security prefix';
	}
	for (var i = 1; i < 6; ++i) {
		if (message.length == 26 + i + +message.substr(26, i)) {
			return message.substr(26 + i);
		}
	}
	throw 'Invalid message - invalid security prefix';
};

function cleanup(value) {
	var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bytes32';
	var api = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parity.api;

	// TODO: make work with arbitrary depth arrays
	if (value instanceof Array && type.match(/bytes[0-9]+/)) {
		// figure out if it's an ASCII string hiding in there:
		var ascii = '';
		for (var i = 0, ended = false; i < value.length && ascii !== null; ++i) {
			if (value[i] === 0) {
				ended = true;
			} else {
				ascii += String.fromCharCode(value[i]);
			}
			if (ended && value[i] !== 0 || !ended && (value[i] < 32 || value[i] >= 128)) {
				ascii = null;
			}
		}
		value = ascii === null ? '0x' + value.map(function (n) {
			return ('0' + n.toString(16)).slice(-2);
		}).join('') : ascii;
	}
	if (type.substr(0, 4) == 'uint' && +type.substr(4) <= 48) {
		value = +value;
	}
	return value;
}