'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.setDefaultTransformBondContext = setDefaultTransformBondContext;
exports.isBond = isBond;

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var defaultContext = typeof parity === 'undefined' ? null : parity.api;

function setDefaultTransformBondContext(c) {
	defaultContext = c;
}

var subscripted = {};
// Any names which should never be subscripted.
var reservedNames = { toJSON: true, toString: true };

var Bond = exports.Bond = function () {
	function Bond() {
		var mayBeNull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

		_classCallCheck(this, Bond);

		this.subscribers = [];
		this.notifies = [];
		this.thens = [];
		this._ready = false;
		this._value = null;
		this.mayBeNull = mayBeNull;
		//		return this.subscriptable();
	}

	_createClass(Bond, [{
		key: 'toString',
		value: function toString() {
			//		console.log(`Converting Bond to string: ${JSON.stringify(this)}`)
			var s = Symbol();
			subscripted[s] = this;
			return s;
		}
	}, {
		key: 'subscriptable',
		value: function subscriptable() {
			var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

			if (depth === 0) return this;
			var r = new Proxy(this, {
				get: function get(receiver, name) {
					//				console.log(`subscriptable.get: ${JSON.stringify(receiver)}, ${JSON.stringify(name)}, ${JSON.stringify(receiver)}: ${typeof(name)}, ${typeof(receiver[name])}`);
					if ((typeof name === 'string' || typeof name === 'number') && (reservedNames[name] || typeof receiver[name] !== 'undefined')) {
						return receiver[name];
					} else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'symbol') {
						if (Bond.knowSymbol(name)) {
							return receiver.sub(Bond.fromSymbol(name)).subscriptable(depth - 1);
						} else {
							//						console.warn(`Unknown symbol given`);
							return null;
						}
					} else {
						//					console.log(`Subscripting: ${JSON.stringify(name)}`)
						return receiver.sub(name).subscriptable(depth - 1);
					}
				}
			});
			//		r.toString = Bond.prototype.toString.bind(this);
			return r;
		}
	}, {
		key: 'reset',
		value: function reset() {
			if (this._ready) {
				this._ready = false;
				this._value = null;
				this.notifies.forEach(function (f) {
					return f();
				});
			}
		}
	}, {
		key: 'changed',
		value: function changed(v) {
			if (typeof v === 'undefined') {
				console.error('Trigger called with undefined value');
				return;
			}
			//		console.log(`maybe changed (${this._value} -> ${v})`);
			if (!this.mayBeNull && v === null) {
				this.reset();
			} else if (!this._ready || JSON.stringify(v) !== JSON.stringify(this._value)) {
				this.trigger(v);
			}
		}
	}, {
		key: 'trigger',
		value: function trigger(v) {
			var _this = this;

			if (typeof v === 'undefined') {
				console.error('Trigger called with undefined value');
				return;
			}
			if (!this.mayBeNull && v === null) {
				this.reset();
			} else {
				//			console.log(`firing (${JSON.stringify(v)})`);
				this._ready = true;
				this._value = v;
				this.notifies.forEach(function (f) {
					return f();
				});
				this.subscribers.forEach(function (f) {
					return f(_this._value);
				});
				this.thens.forEach(function (f) {
					return f(_this._value);
				});
				this.thens = [];
			}
		}
	}, {
		key: 'drop',
		value: function drop() {}
	}, {
		key: 'notify',
		value: function notify(f) {
			this.notifies.push(f);
			if (this._ready) {
				f();
			}
		}
	}, {
		key: 'tie',
		value: function tie(f) {
			this.subscribers.push(f);
			if (this._ready) {
				f(this._value);
			}
			return this;
		}
	}, {
		key: 'subscribe',
		value: function subscribe(f) {
			console.warn('Bond.subscribe is deprecated. Use Bond.tie instead.');
			return this.tie(f);
		}
	}, {
		key: 'ready',
		value: function ready() {
			return this._ready;
		}
	}, {
		key: 'then',
		value: function then(f) {
			if (this._ready) {
				f(this._value);
			} else {
				this.thens.push(f);
			}
			return this;
		}
	}, {
		key: 'map',
		value: function map(f) {
			return new TransformBond(f, [this]);
		}
	}, {
		key: 'sub',
		value: function sub(name) {
			return new TransformBond(function (r, n) {
				return r[n];
			}, [this, name]);
		}

		// Takes a Bond which evaluates to a = [a[0], a[1], ...]
		// Returns Bond which evaluates to:
		// null iff a.length === 0
		// f(i, a[0])[0] iff f(i, a[0])[1] === true
		// fold(f(0, a[0]), a.mid(1)) otherwise

	}, {
		key: 'reduce',
		value: function reduce(accum, init) {
			var nextItem = function nextItem(acc, rest) {
				var next = rest.pop();
				return Bond.promise([accum(acc, next)]).then(function (_ref) {
					var _ref2 = _slicedToArray(_ref, 1),
					    _ref2$ = _slicedToArray(_ref2[0], 2),
					    v = _ref2$[0],
					    i = _ref2$[1];

					return i ? v : rest.length > 0 ? nextItem(v, rest) : null;
				});
			};
			return this.map(function (a) {
				return nextItem(init, a);
			});
		}
	}], [{
		key: 'knowSymbol',
		value: function knowSymbol(name) {
			return !!subscripted[name];
		}
	}, {
		key: 'fromSymbol',
		value: function fromSymbol(name) {
			var sub = subscripted[name];
			delete subscripted[name];
			return sub;
		}
	}, {
		key: 'all',
		value: function all(list) {
			return new TransformBond(function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				return args;
			}, list);
		}
	}, {
		key: 'promise',
		value: function promise(list) {
			return new Promise(function (resolve, reject) {
				var finished = 0;
				var l = [];
				l.length = list.length;

				var done = function done(i, v) {
					//				console.log(`done ${i} ${v}`);
					l[i] = v;
					finished++;
					//				console.log(`finished ${finished}; l.length ${l.length}`);
					if (finished === l.length) {
						//					console.log(`resolving with ${l}`);
						resolve(l);
					}
				};

				list.forEach(function (v, i) {
					if (v instanceof Bond) {
						v.then(function (x) {
							return done(i, x);
						});
					} else if (v instanceof Promise) {
						v.then(function (x) {
							return done(i, x);
						}, reject);
					} else {
						done(i, v);
					}
				});
			});
		}
	}]);

	return Bond;
}();

function isReady(x) {
	var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) return x._ready;else if (x instanceof Promise) return typeof x._value !== 'undefined';else if (deep && x.constructor === Array) return x.every(function (i) {
			return isReady(i, false);
		});else if (deep && x.constructor === Object) return Object.keys(x).every(function (k) {
			return isReady(x[k], false);
		});else return true;
	} else return true;
}

function isBond(x) {
	var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) return true;else if (x instanceof Promise) return false;else if (deep && x.constructor === Array) return x.some(function (i) {
			return isBond(i, false);
		});else if (deep && x.constructor === Object) return Object.keys(x).some(function (k) {
			return isBond(x[k], false);
		});else return false;
	} else return false;
}

function mapped(x) {
	var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	if (!isReady(x, deep)) {
		throw 'Internal error: Unready value being mapped';
	}
	//	console.log(`x info: ${x} ${typeof(x)} ${x.constructor.name} ${JSON.stringify(x)}; deep: ${deep}`);
	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) {
			if (x._ready !== true) {
				throw 'Internal error: Unready Bond being mapped';
			}
			if (typeof x._value === 'undefined') {
				throw 'Internal error: Ready Bond with undefined value in mapped';
			}
			//			console.log(`Bond: ${JSON.stringify(x._value)}}`);
			return x._value;
		} else if (x instanceof Promise) {
			if (typeof x._value === 'undefined') {
				throw 'Internal error: Ready Promise has undefined value';
			}
			//			console.log(`Promise: ${JSON.stringify(x._value)}}`);
			return x._value;
		} else if (deep && x.constructor === Array && x.some(function (i) {
			return i instanceof Bond || i instanceof Promise;
		})) {
			//			console.log(`Deep array...`);
			var _o = x.slice().map(function (i) {
				return mapped(i, false);
			});
			//			console.log(`...Deep array: ${JSON.stringify(o)}`);
			return _o;
		} else if (deep && x.constructor === Object && Object.keys(x).some(function (i) {
			return x[i] instanceof Bond || x[i] instanceof Promise;
		})) {
			var o = {};
			//			console.log(`Deep object...`);
			Object.keys(x).forEach(function (k) {
				o[k] = mapped(x[k], false);
			});
			//			console.log(`...Deep object: ${JSON.stringify(o)}`);
			return o;
		} else {
			//			console.log(`Shallow object.`);
			return x;
		}
	} else {
		//		console.log(`Basic value.`);
		return x;
	}
}

function deepTie(x, poll) {
	var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null) {
		if (x instanceof Bond) {
			x.notify(poll);
			return true;
		} else if (x instanceof Promise) {
			x.then(function (v) {
				x._value = v;poll();
			});
			return true;
		} else if (deep && x.constructor === Array && x.findIndex(function (i) {
			return i instanceof Bond || i instanceof Promise;
		}) != -1) {
			var r = false;
			x.forEach(function (i) {
				r = deepTie(i, poll, false) || r;
			});
			return r;
		} else if (deep && x.constructor === Object && Object.keys(x).findIndex(function (i) {
			return x[i] instanceof Bond || x[i] instanceof Promise;
		}) != -1) {
			var r = false;
			Object.keys(x).forEach(function (k) {
				r = deepTie(x[k], poll, false) || r;
			});
			return r;
		} else {
			return false;
		}
	} else {
		return false;
	}
}

var ReactiveBond = exports.ReactiveBond = function (_Bond) {
	_inherits(ReactiveBond, _Bond);

	function ReactiveBond(a, d) {
		var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (args) {
			return _this2.changed(args);
		};
		var mayBeNull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

		_classCallCheck(this, ReactiveBond);

		var _this2 = _possibleConstructorReturn(this, (ReactiveBond.__proto__ || Object.getPrototypeOf(ReactiveBond)).call(this, mayBeNull));

		var poll = function poll() {
			if (a.every(isReady)) {
				//				console.log(`poll: All dependencies good...`);
				var am = a.map(function (i) {
					return mapped(i, true);
				});
				//				console.log(`poll: Mapped dependencies: ${JSON.stringify(am)}`);
				execute.bind(_this2)(am);
			} else {
				//				console.log("poll: One or more dependencies undefined");
				_this2.reset();
			}
		};

		d.forEach(function (i) {
			return i.notify(poll);
		});
		var nd = 0;
		a.forEach(function (i) {
			if (deepTie(i, poll)) nd++;
		});
		if (nd == 0 && d.length == 0) {
			poll();
		}
		return _this2;
	}

	_createClass(ReactiveBond, [{
		key: 'drop',
		value: function drop() {
			// TODO clear up all our dependency `notify`s.
		}
	}]);

	return ReactiveBond;
}(Bond);

// Just a one-off.


var ReactivePromise = exports.ReactivePromise = function (_ReactiveBond) {
	_inherits(ReactivePromise, _ReactiveBond);

	function ReactivePromise(a, d) {
		var execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (args) {
			return _this3.changed(args);
		};

		var _this3;

		var mayBeNull = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

		_classCallCheck(this, ReactivePromise);

		var done = false;
		return _this3 = _possibleConstructorReturn(this, (ReactivePromise.__proto__ || Object.getPrototypeOf(ReactivePromise)).call(this, a, d, function (args) {
			if (!done) {
				done = true;
				execute.bind(_this3)(args);
			}
		}, mayBeNull));
	}

	return ReactivePromise;
}(ReactiveBond);

/// f is function which returns a promise. a is a set of dependencies
/// which must be passed to f as args. d are dependencies whose values are
/// unneeded. any entries of a which are reactive promises then is it their
/// underlying value which is passed.
///
/// we return a bond (an ongoing promise).


var TransformBond = exports.TransformBond = function (_ReactiveBond2) {
	_inherits(TransformBond, _ReactiveBond2);

	function TransformBond(f) {
		var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
		var d = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
		var latched = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
		var mayBeNull = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
		var context = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : defaultContext;

		_classCallCheck(this, TransformBond);

		return _possibleConstructorReturn(this, (TransformBond.__proto__ || Object.getPrototypeOf(TransformBond)).call(this, a, d, function (args) {
			//			console.log(`Applying: ${JSON.stringify(args)}`);
			var r = f.apply(context, args);
			if (typeof r === 'undefined') {
				console.warn('Transformation returned undefined: Applied ' + f + ' to ' + JSON.stringify(args) + '.');
				this.reset();
			} else if (r instanceof Promise) {
				if (!latched) {
					this.reset();
				}
				r.then(this.changed.bind(this));
			} else {
				this.changed(r);
			}
		}, mayBeNull, context));
	}

	return TransformBond;
}(ReactiveBond);

var TimeBond = exports.TimeBond = function (_Bond2) {
	_inherits(TimeBond, _Bond2);

	function TimeBond() {
		_classCallCheck(this, TimeBond);

		var _this5 = _possibleConstructorReturn(this, (TimeBond.__proto__ || Object.getPrototypeOf(TimeBond)).call(this));

		var t = function () {
			this.trigger(Date.now());
		}.bind(_this5);
		if (typeof window !== 'undefined') _this5.interval = window.setInterval(t, 1000);
		t();
		return _this5;
	}

	_createClass(TimeBond, [{
		key: 'drop',
		value: function drop() {
			if (typeof window !== 'undefined') window.clearInterval(this.interval);
		}
	}]);

	return TimeBond;
}(Bond);